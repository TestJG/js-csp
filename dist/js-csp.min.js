(function(l, s) {
  'object' == typeof exports && 'object' == typeof module
    ? (module.exports = s())
    : 'function' == typeof define && define.amd
        ? define('csp', [], s)
        : 'object' == typeof exports ? (exports.csp = s()) : (l.csp = s());
})(this, function() {
  return (function(a) {
    function l(u) {
      if (s[u]) return s[u].exports;
      var o = (s[u] = { i: u, l: !1, exports: {} });
      return a[u].call(o.exports, o, o.exports, l), (o.l = !0), o.exports;
    }
    var s = {};
    return (l.m = a), (l.c = s), (l.i = function(u) {
      return u;
    }), (l.d = function(u, o, c) {
      l.o(u, o) ||
        Object.defineProperty(u, o, {
          configurable: !1,
          enumerable: !0,
          get: c,
        });
    }), (l.n = function(u) {
      var o = u && u.__esModule
        ? function() {
            return u['default'];
          }
        : function() {
            return u;
          };
      return l.d(o, 'a', o), o;
    }), (l.o = function(u, o) {
      return Object.prototype.hasOwnProperty.call(u, o);
    }), (l.p = ''), l((l.s = 10));
  })([
    function(a, l, s) {
      'use strict';
      function u(M) {
        return console.log('error in channel transformer', M.stack), A;
      }
      function o(M, E, O) {
        const U = (E || u)(O);
        return U !== A && M.add(U), M;
      }
      function c(M) {
        return E => ({
          '@@transducer/step': (O, U) => {
            try {
              return E['@@transducer/step'](O, U);
            } catch (F) {
              return o(O, M, F);
            }
          },
          '@@transducer/result': O => {
            try {
              return E['@@transducer/result'](O);
            } catch (U) {
              return o(O, M, U);
            }
          },
        });
      }
      l.c = function(M, E, O) {
        let U;
        if (E) {
          if (!M) throw new Error('Only buffered channels can use transducers');
          U = E(_);
        } else
          U = _;
        return new y(s.i(h.e)(32), s.i(h.e)(32), M, c(O)(U));
      };
      var h = s(2), b = s(1), g = s(13);
      const x = 64, k = 1024, A = null;
      l.a = A;
      class y {
        constructor(M, E, O, U) {
          (this.buf = O), (this.xform = U), (this.takes = M), (this.puts = E), (this.dirtyTakes = 0), (this.dirtyPuts = 0), (this.closed = !1);
        }
        put(M, E) {
          if (M === A) throw new Error('Cannot put CLOSED on a channel.');
          if (!E.isActive()) return null;
          if (this.closed) return E.commit(), new b.a(!1);
          if (this.buf && !this.buf.isFull()) {
            E.commit();
            const O = s.i(g.a)(this.xform['@@transducer/step'](this.buf, M));
            for (; 0 < this.buf.count() && 0 < this.takes.length; ) {
              const U = this.takes.pop();
              U.isActive() && s.i(g.b)(U.commit(), this.buf.remove());
            }
            return O && this.close(), new b.a(!0);
          }
          for (; 0 < this.takes.length; ) {
            const O = this.takes.pop();
            if (O.isActive())
              return E.commit(), s.i(g.b)(O.commit(), M), new b.a(!0);
          }
          if (
            (this.dirtyPuts > x
              ? (this.puts.cleanup(O =>
                  O.handler.isActive()), (this.dirtyPuts = 0))
              : (this.dirtyPuts += 1), E.isBlockable())
          ) {
            if (this.puts.length >= k)
              throw new Error(
                `No more than ${k} pending puts are allowed on a single channel.`
              );
            this.puts.unboundedUnshift(new b.b(E, M));
          }
          return null;
        }
        take(M) {
          if (!M.isActive()) return null;
          if (this.buf && 0 < this.buf.count()) {
            M.commit();
            const E = this.buf.remove();
            for (; 0 < this.puts.length && !this.buf.isFull(); ) {
              const O = this.puts.pop();
              O.handler.isActive() &&
                (s.i(g.b)(O.handler.commit(), !0), s.i(g.a)(
                  this.xform['@@transducer/step'](this.buf, O.value)
                ) && this.close());
            }
            return new b.a(E);
          }
          for (; 0 < this.puts.length; ) {
            const E = this.puts.pop();
            if (E.handler.isActive())
              return M.commit(), s.i(g.b)(E.handler.commit(), !0), new b.a(
                E.value
              );
          }
          if (this.closed) return M.commit(), new b.a(A);
          if (
            (this.dirtyTakes > x
              ? (this.takes.cleanup(E => E.isActive()), (this.dirtyTakes = 0))
              : (this.dirtyTakes += 1), M.isBlockable())
          ) {
            if (this.takes.length >= k)
              throw new Error(
                `No more than ${k} pending takes are allowed on a single channel.`
              );
            this.takes.unboundedUnshift(M);
          }
          return null;
        }
        close() {
          if (!this.closed) {
            if (((this.closed = !0), this.buf))
              for (
                this.xform['@@transducer/result'](this.buf);
                0 < this.buf.count() && 0 < this.takes.length;
                
              ) {
                const M = this.takes.pop();
                M.isActive() && s.i(g.b)(M.commit(), this.buf.remove());
              }
            s.i(g.c)(this.takes, M => {
              M.isActive() && s.i(g.b)(M.commit(), A);
            }), s.i(g.c)(this.puts, M => {
              M.handler.isActive() && s.i(g.b)(M.handler.commit(), !1);
            });
          }
        }
        isClosed() {
          return this.closed;
        }
      }
      l.b = y;
      const _ = {
        '@@transducer/init': () => {
          throw new Error('init not available');
        },
        '@@transducer/result': M => M,
        '@@transducer/step': (M, E) => {
          return M.add(E), M;
        },
      };
    },
    function(a, l) {
      'use strict';
      l.a = class {
        constructor(c) {
          this.value = c;
        }
      };
      l.b = class {
        constructor(c, d) {
          (this.handler = c), (this.value = d);
        }
      };
    },
    function(a, l) {
      'use strict';
      function u(_, M, E, O, U) {
        for (let F = 0; F < U; F += 1)
          E[O + F] = _[M + F];
      }
      function o(_) {
        if (0 >= _) throw new Error("Can't create a ring buffer of size 0");
        return new g(0, 0, 0, Array(_));
      }
      (l.e = o), (l.a = function(_) {
        return new x(o(_), _);
      }), (l.b = function(_) {
        return new k(o(_), _);
      }), (l.c = function(_) {
        return new A(o(_), _);
      }), (l.d = function() {
        return new y(y.NO_VALUE);
      });
      class g {
        constructor(_, M, E, O) {
          (this.head = _), (this.tail = M), (this.length = E), (this.arr = O);
        }
        pop() {
          if (0 !== this.length) {
            const _ = this.arr[this.tail];
            return (this.arr[this.tail] = void 0), (this.tail = (this.tail +
              1) %
              this.arr.length), (this.length -= 1), _;
          }
        }
        unshift(_) {
          (this.arr[this.head] = _), (this.head = (this.head + 1) %
            this.arr.length), (this.length += 1);
        }
        unboundedUnshift(_) {
          this.length + 1 === this.arr.length && this.resize(), this.unshift(_);
        }
        resize() {
          const _ = 2 * this.arr.length, M = Array(_);
          this.tail < this.head
            ? (u(
                this.arr,
                this.tail,
                M,
                0,
                this.length
              ), (this.tail = 0), (this.head = this.length), (this.arr = M))
            : this.tail > this.head
                ? (u(this.arr, this.tail, M, 0, this.arr.length - this.tail), u(
                    this.arr,
                    0,
                    M,
                    this.arr.length - this.tail,
                    this.head
                  ), (this.tail = 0), (this.head = this.length), (this.arr = M))
                : this.tail === this.head &&
                    ((this.tail = 0), (this.head = 0), (this.arr = M));
        }
        cleanup(_) {
          for (let M = this.length; 0 < M; M -= 1) {
            const E = this.pop();
            _(E) && this.unshift(E);
          }
        }
      }
      class x {
        constructor(_, M) {
          (this.buffer = _), (this.n = M);
        }
        isFull() {
          return this.buffer.length === this.n;
        }
        remove() {
          return this.buffer.pop();
        }
        add(_) {
          this.buffer.unboundedUnshift(_);
        }
        closeBuffer() {}
        count() {
          return this.buffer.length;
        }
      }
      class k {
        constructor(_, M) {
          (this.buffer = _), (this.n = M);
        }
        isFull() {
          return !1;
        }
        remove() {
          return this.buffer.pop();
        }
        add(_) {
          this.buffer.length !== this.n && this.buffer.unshift(_);
        }
        closeBuffer() {}
        count() {
          return this.buffer.length;
        }
      }
      class A {
        constructor(_, M) {
          (this.buffer = _), (this.n = M);
        }
        isFull() {
          return !1;
        }
        remove() {
          return this.buffer.pop();
        }
        add(_) {
          this.buffer.length === this.n && this.remove(), this.buffer.unshift(
            _
          );
        }
        closeBuffer() {}
        count() {
          return this.buffer.length;
        }
      }
      class y {
        constructor(_) {
          this.value = _;
        }
        isFull() {
          return !1;
        }
        remove() {
          return this.value;
        }
        add(_) {
          y.isUndelivered(this.value) && (this.value = _);
        }
        closeBuffer() {
          y.isUndelivered(this.value) && (this.value = null);
        }
        count() {
          return y.isUndelivered(this.value) ? 0 : 1;
        }
      }
      (y.NO_VALUE = '@@PromiseBuffer/NO_VALUE'), (y.isUndelivered = _ =>
        y.NO_VALUE === _);
    },
    function(a, l, s) {
      'use strict';
      function u(F, I, C) {
        const T = F.put(I, new A.a(!0, C));
        T && C && C(T.value);
      }
      function o(F, I) {
        const C = F.take(new A.a(!0, I));
        C && I && I(C.value);
      }
      (l.g = u), (l.h = o), (l.b = function(F) {
        return new y.a(F);
      }), (l.a = function(F, I) {
        return new y.b(F, I);
      }), (l.e = function(F) {
        return new y.c(F);
      }), (l.f = function(F, I) {
        return new y.d(F, I);
      }), (l.d = function(F) {
        if (F.closed) return null;
        const I = F.take(new A.a(!1));
        return I ? I.value : null;
      }), (l.c = function(F, I) {
        if (F.closed) return !1;
        const C = F.put(I, new A.a(!1));
        return C instanceof _.a;
      });
      var k = s(12), A = s(7), y = s(11), _ = s(1), M = s(0), E = s(4);
      l.i = class {
        constructor(F, I) {
          (this.schedule = C => {
            setTimeout(() => this.run(C));
          }), (this.gen = F), (this.finished = !1), (this.onFinishFunc = I);
        }
        run(F) {
          if (!this.finished) {
            const { done: I, value: C } = this.gen.next(F);
            I
              ? ((this.finished = !0), this.onFinishFunc(C))
              : C instanceof y.a
                  ? o(C.channel, this.schedule)
                  : C instanceof y.b
                      ? u(C.channel, C.value, this.schedule)
                      : C instanceof y.c
                          ? s.i(E.a)(this.schedule, C.msec)
                          : C instanceof y.d
                              ? s.i(k.a)(C.operations, this.schedule, C.options)
                              : C instanceof M.b
                                  ? o(C, this.schedule)
                                  : this.schedule(C);
          }
        }
      };
    },
    function(a, l, s) {
      'use strict';
      function u() {
        (x && g) ||
          ((x = !0), setTimeout(() => {
            let k = 0;
            for ((g = !0), (x = !1); k < h; ) {
              const A = b.pop();
              if (A) A(), (k += 1);
              else break;
            }
            (g = !1), 0 < b.length && u();
          }));
      }
      (l.b = function(k) {
        b.unboundedUnshift(k), u();
      }), (l.a = function(k, A) {
        setTimeout(k, A);
      });
      var d = s(2);
      const h = 1024, b = s.i(d.e)(32);
      let g = !1, x = !1;
    },
    function(a, l, s) {
      'use strict';
      function u(x) {
        const k = s.i(g.c)(s.i(h.a)(1)),
          A = new b.i(x, y => {
            y === g.a ? k.close() : s.i(b.g)(k, y, () => k.close());
          });
        return A.run(), k;
      }
      (l.a = u), (l.b = function(x, k = []) {
        return u(x(...k));
      }), (l.c = function(x, k, A) {
        return 'number' == typeof x
          ? s.i(g.c)(0 === x ? null : s.i(h.a)(x), k, A)
          : s.i(g.c)(x, k, A);
      }), (l.d = function(x, k) {
        return s.i(g.c)(s.i(h.d)(), x, k);
      });
      var h = s(2), b = s(3), g = s(0);
    },
    function(a, l, s) {
      'use strict';
      s(0);
      const o = {
        toString() {
          return '[object DEFAULT]';
        },
      };
      l.a = o;
      l.b = class {
        constructor(d, h) {
          (this.value = d), (this.channel = h);
        }
      };
    },
    function(a, l, s) {
      'use strict';
      var u = s(23), o = s.n(u), c = s(1);
      l.a = class {
        constructor(b, g) {
          (this.blockable = b), (this.func = g || o.a);
        }
        isActive() {
          return !0;
        }
        isBlockable() {
          return this.blockable;
        }
        commit() {
          return this.func;
        }
      };
      l.b = class {
        constructor(b, g) {
          (this.flag = b), (this.func = g);
        }
        isActive() {
          return this.flag.value;
        }
        isBlockable() {
          return !0;
        }
        commit() {
          return (this.flag.value = !1), this.func;
        }
      };
    },
    function(a, l, s) {
      'use strict';
      function c(ne, le, se) {
        const ue = s.i(H.c)(se);
        return s.i(H.b)(function*() {
          for (;;) {
            const oe = yield s.i(G.b)(le);
            if (oe === R.a) {
              ue.close();
              break;
            }
            ne(oe) && (yield s.i(G.a)(ue, oe));
          }
        }), ue;
      }
      function d(ne, le) {
        return {
          isClosed() {
            return le.isClosed();
          },
          close() {
            le.close();
          },
          put(se, ue) {
            return ne(se) ? le.put(se, ue) : new z.a(!le.isClosed());
          },
          take(se) {
            return le.take(se);
          },
        };
      }
      function* g(ne, le, se) {
        for (;;) {
          const ue = yield s.i(G.b)(le);
          if (ue === R.a) {
            se.close();
            break;
          } else {
            const oe = ne(ue), ce = oe.length;
            for (let re = 0; re < ce; re += 1)
              yield s.i(G.a)(se, oe[re]);
            if (se.isClosed()) break;
          }
        }
      }
      function _(ne, le, se) {
        return s.i(H.b)(
          function*() {
            for (let ue = le; ; ) {
              const oe = yield s.i(G.b)(se);
              if (oe === R.a) return ue;
              ue = ne(ue, oe);
            }
          },
          [],
          !0
        );
      }
      function M(ne, le, se) {
        return s.i(H.b)(function*() {
          const ue = le.length;
          for (let oe = 0; oe < ue; oe += 1) yield s.i(G.a)(ne, le[oe]);
          se || ne.close();
        });
      }
      function P(ne) {
        let le = ne[Q];
        if (!le) {
          const se = K();
          (le = se), (ne[Q] = se);
        }
        return le;
      }
      function S(ne) {
        function le(ce) {
          return re => {
            (oe -= 1), 0 === oe && s.i(G.g)(ue, !0), re || se.untap(ce.channel);
          };
        }
        const se = new Y(ne), ue = s.i(H.c)(1);
        let oe;
        return s.i(H.b)(function*() {
          for (;;) {
            const ce = yield s.i(G.b)(ne), re = se.taps;
            let de;
            if (ce === R.a) {
              Object.keys(re).forEach(fe => {
                (de = re[fe]), de.keepOpen || de.channel.close();
              }), se.untapAll();
              break;
            }
            oe = Object.keys(re).length;
            const pe = oe;
            Object.keys(re).forEach(fe => {
              (de = re[fe]), s.i(G.g)(de.channel, ce, le(de));
            }), 0 < pe && (yield s.i(G.b)(ue));
          }
        }), se;
      }
      function j(ne) {
        const le = new te(ne);
        return s.i(H.b)(function*() {
          for (let se = le._getAllState(); ; ) {
            const ue = yield s.i(G.f)(se.reads), oe = ue.value, ce = ue.channel;
            if (oe === R.a)
              delete le.stateMap[P(ce)], (se = le._getAllState());
            else if (ce === le.change)
              se = le._getAllState();
            else {
              const re = se.solos;
              if (
                -1 < re.indexOf(ce) ||
                (0 === re.length && !(-1 < se.mutes.indexOf(ce)))
              ) {
                const de = yield s.i(G.a)(ne, oe);
                if (!de) break;
              }
            }
          }
        }), le;
      }
      function D() {
        return null;
      }
      function N(ne, le, se = D) {
        const ue = new ie(ne, le, se);
        return s.i(H.b)(function*() {
          for (;;) {
            const oe = yield s.i(G.b)(ne), ce = ue.mults;
            if (oe === R.a) {
              Object.keys(ce).forEach(pe => {
                ce[pe].muxch().close();
              });
              break;
            }
            const re = le(oe), de = ce[re];
            if (de) {
              const pe = yield s.i(G.a)(de.muxch(), oe);
              pe || delete ce[re];
            }
          }
        }), ue;
      }
      function V(ne, le, se, ue, oe) {
        if (0 >= ne) throw new Error('n must be positive');
        const ce = s.i(H.c)(ne), re = s.i(H.c)(ne);
        return X()(ne, () => {
          s.i(H.b)(
            function*(de, pe, fe) {
              for (;;) {
                const he = yield s.i(G.b)(pe);
                if (!de(he)) {
                  fe.close();
                  break;
                }
              }
            },
            [oe, ce, re]
          );
        }), s.i(H.b)(
          function*(de, pe, fe) {
            for (;;) {
              const he = yield s.i(G.b)(pe);
              if (he === R.a) {
                de.close();
                break;
              }
              const be = s.i(H.c)(1);
              yield s.i(G.a)(de, [he, be]), yield s.i(G.a)(fe, be);
            }
          },
          [ce, se, re]
        ), s.i(H.b)(
          function*(de, pe, fe) {
            for (;;) {
              const he = yield s.i(G.b)(de);
              if (he === R.a) {
                pe && fe.close();
                break;
              }
              for (const be = yield s.i(G.b)(he); ; ) {
                const me = yield s.i(G.b)(be);
                if (me === R.a) break;
                yield s.i(G.a)(fe, me);
              }
            }
          },
          [re, ue, le]
        ), le;
      }
      (l.a = function(ne, le) {
        return {
          isClosed() {
            return le.isClosed();
          },
          close() {
            le.close();
          },
          put(se, ue) {
            return le.put(se, ue);
          },
          take(se) {
            const ue = le.take({
              isActive() {
                return se.isActive();
              },
              commit() {
                const oe = se.commit();
                return ce => oe(ce === R.a ? R.a : ne(ce));
              },
            });
            if (ue) {
              const oe = ue.value;
              return new z.a(oe === R.a ? R.a : ne(oe));
            }
            return null;
          },
        };
      }), (l.b = function(ne, le) {
        return {
          isClosed() {
            return le.isClosed();
          },
          close() {
            le.close();
          },
          put(se, ue) {
            return le.put(ne(se), ue);
          },
          take(se) {
            return le.take(se);
          },
        };
      }), (l.c = c), (l.d = d), (l.e = function(ne, le) {
        return c(se => !ne(se), le);
      }), (l.f = function(ne, le) {
        return d(se => !ne(se), le);
      }), (l.g = function(ne, le, se) {
        const ue = s.i(H.c)(se);
        return s.i(H.b)(g, [ne, le, ue]), ue;
      }), (l.h = function(ne, le, se) {
        const ue = s.i(H.c)(se);
        return s.i(H.b)(g, [ne, ue, le]), ue;
      }), (l.i = function(ne, le, se) {
        return s.i(H.b)(function*() {
          for (;;) {
            const ue = yield s.i(G.b)(ne);
            if (ue === R.a) {
              se || le.close();
              break;
            }
            if (!(yield s.i(G.a)(le, ue))) break;
          }
        }), le;
      }), (l.j = function(ne, le, se, ue) {
        const oe = s.i(H.c)(se), ce = s.i(H.c)(ue);
        return s.i(H.b)(function*() {
          for (;;) {
            const re = yield s.i(G.b)(le);
            if (re === R.a) {
              oe.close(), ce.close();
              break;
            }
            yield s.i(G.a)(ne(re) ? oe : ce, re);
          }
        }), [oe, ce];
      }), (l.k = _), (l.l = M), (l.m = function(ne) {
        const le = s.i(H.c)(ne.length);
        return M(le, ne), le;
      }), (l.n = function(ne, le, se) {
        const ue = s.i(H.c)(se),
          oe = le.length,
          ce = Array(oe),
          re = s.i(H.c)(1);
        let de;
        const pe = Array(oe),
          fe = he =>
            be => {
              (ce[he] = be), (de -= 1), 0 === de && s.i(G.g)(re, ce.slice(0));
            };
        for (let he = 0; he < oe; he += 1)
          pe[he] = fe(he);
        return s.i(H.b)(function*() {
          for (;;) {
            de = oe;
            for (let be = 0; be < oe; be += 1) try {
                s.i(G.h)(le[be], pe[be]);
              } catch (me) {
                de -= 1;
              }
            const he = yield s.i(G.b)(re);
            for (
              let be = 0;
              be < oe;
              be += 1
            ) if (he[be] === R.a) return void ue.close();
            yield s.i(G.a)(ue, ne(...he));
          }
        }), ue;
      }), (l.o = function(ne, le) {
        const se = s.i(H.c)(le), ue = ne.slice(0);
        return s.i(H.b)(function*() {
          for (;;) {
            if (0 === ue.length) break;
            const oe = yield s.i(G.f)(ue), ce = oe.value;
            if (ce === R.a) {
              const re = ue.indexOf(oe.channel);
              ue.splice(re, 1);
            } else
              yield s.i(G.a)(se, ce);
          }
          se.close();
        }), se;
      }), (l.p = function(ne, le) {
        const se = ne.slice(0);
        return _(
          (ue, oe) => {
            return ue.push(oe), ue;
          },
          se,
          le
        );
      }), (l.y = function(ne, le, se) {
        const ue = s.i(H.c)(se);
        return s.i(H.b)(function*() {
          for (let oe = 0; oe < ne; oe += 1) {
            const ce = yield s.i(G.b)(le);
            if (ce === R.a) break;
            yield s.i(G.a)(ue, ce);
          }
          ue.close();
        }), ue;
      }), (l.q = function(ne, le) {
        const se = s.i(H.c)(le);
        let ue = J;
        return s.i(H.b)(function*() {
          for (;;) {
            const oe = yield s.i(G.b)(ne);
            if (oe === R.a) break;
            oe !== ue && ((ue = oe), yield s.i(G.a)(se, oe));
          }
          se.close();
        }), se;
      }), (l.r = function(ne, le, se) {
        const ue = s.i(H.c)(se);
        let oe = [], ce = J;
        return s.i(H.b)(function*() {
          for (;;) {
            const re = yield s.i(G.b)(le);
            if (re === R.a) {
              0 < oe.length && (yield s.i(G.a)(ue, oe)), ue.close();
              break;
            } else {
              const de = ne(re);
              de === ce || ce === J
                ? oe.push(re)
                : (yield s.i(G.a)(ue, oe), (oe = [re])), (ce = de);
            }
          }
        }), ue;
      }), (l.s = function(ne, le, se) {
        const ue = s.i(H.c)(se);
        return s.i(H.b)(function*() {
          for (;;) {
            const oe = Array(ne);
            for (let ce = 0; ce < ne; ce += 1) {
              const re = yield s.i(G.b)(le);
              if (re === R.a)
                return 0 < ce &&
                  (yield s.i(G.a)(ue, oe.slice(0, ce))), void ue.close();
              oe[ce] = re;
            }
            yield s.i(G.a)(ue, oe);
          }
        }), ue;
      }), (l.t = S), (l.u = j), (l.v = N), (l.w = function(ne, le, se, ue, oe) {
        return V(1, ne, se, !ue, function(re) {
          if (re === R.a) return null;
          const [de, pe] = re, fe = s.i(H.c)(1, le, oe);
          return s.i(H.b)(function*(he, be) {
            yield s.i(G.a)(he, be), fe.close();
          }, [fe, de]), s.i(G.g)(pe, fe), !0;
        });
      }), (l.x = function(ne, le, se, ue, oe) {
        return V(ne, le, ue, !oe, function(re) {
          if (re === R.a) return null;
          const [de, pe] = re, fe = s.i(H.c)(1);
          return se(de, fe), s.i(G.g)(pe, fe), !0;
        });
      });
      var q = s(25), X = s.n(q), z = s(1), R = s(0), G = s(3), H = s(5);
      const J = {},
        K = (() => {
          let ne = 0;
          return () => {
            return (ne += 1), `${ne}`;
          };
        })(),
        Q = '__csp_channel_id';
      class W {
        constructor(ne, le) {
          (this.channel = ne), (this.keepOpen = le);
        }
      }
      class Y {
        constructor(ne) {
          (this.taps = {}), (this.ch = ne);
        }
        muxch() {
          return this.ch;
        }
        tap(ne, le) {
          this.taps[P(ne)] = new W(ne, le);
        }
        untap(ne) {
          delete this.taps[P(ne)];
        }
        untapAll() {
          this.taps = {};
        }
      }
      (S.tap = (ne, le, se) => {
        return ne.tap(le, se), le;
      }), (S.untap = (ne, le) => {
        ne.untap(le);
      }), (S.untapAll = ne => {
        ne.untapAll();
      });
      const Z = 'mute', $ = 'pause', ae = [Z, $];
      class te {
        constructor(ne) {
          (this.ch = ne), (this.stateMap = {}), (this.change = s.i(
            H.c
          )()), (this.soloMode = Z);
        }
        _changed() {
          s.i(G.g)(this.change, !0);
        }
        _getAllState() {
          const ne = this.stateMap, le = [], se = [], ue = [];
          let oe;
          Object.keys(ne).forEach(de => {
            const pe = ne[de], fe = pe.state, he = pe.channel;
            fe['solo'] && le.push(he), fe[Z] && se.push(he), fe[$] &&
              ue.push(he);
          });
          let ce, re;
          if (this.soloMode === $ && 0 < le.length) {
            for (
              (re = le.length), (oe = Array(re + 1)), (ce = 0);
              ce < re;
              ce += 1
            )
              oe[ce] = le[ce];
            oe[re] = this.change;
          } else
            (oe = []), Object.keys(ne).forEach(de => {
              const pe = ne[de], fe = pe.channel;
              0 > ue.indexOf(fe) && oe.push(fe);
            }), oe.push(this.change);
          return { solos: le, mutes: se, reads: oe };
        }
        admix(ne) {
          (this.stateMap[P(ne)] = { channel: ne, state: {} }), this._changed();
        }
        unmix(ne) {
          delete this.stateMap[P(ne)], this._changed();
        }
        unmixAll() {
          (this.stateMap = {}), this._changed();
        }
        toggle(ne) {
          const le = ne.length;
          for (let se = 0; se < le; se += 1) {
            const ue = ne[se][0], oe = P(ue), ce = ne[se][1];
            let re = this.stateMap[oe];
            if (!re) {
              const de = { channel: ue, state: {} };
              (re = de), (this.stateMap[oe] = de);
            }
            Object.keys(ce).forEach(de => {
              re.state[de] = ce[de];
            });
          }
          this._changed();
        }
        setSoloMode(ne) {
          if (0 > ae.indexOf(ne))
            throw new Error('Mode must be one of: ', ae.join(', '));
          (this.soloMode = ne), this._changed();
        }
      }
      (j.add = function(le, se) {
        le.admix(se);
      }), (j.remove = function(le, se) {
        le.unmix(se);
      }), (j.removeAll = function(le) {
        le.unmixAll();
      }), (j.toggle = function(le, se) {
        le.toggle(se);
      }), (j.setSoloMode = function(le, se) {
        le.setSoloMode(se);
      });
      class ie {
        constructor(ne, le, se) {
          (this.ch = ne), (this.topicFn = le), (this.bufferFn = se), (this.mults = {
          });
        }
        _ensureMult(ne) {
          let le = this.mults[ne];
          const se = this.bufferFn;
          if (!le) {
            const ue = S(s.i(H.c)(se(ne)));
            (le = ue), (this.mults[ne] = ue);
          }
          return le;
        }
        sub(ne, le, se) {
          const ue = this._ensureMult(ne);
          return S.tap(ue, le, se);
        }
        unsub(ne, le) {
          const se = this.mults[ne];
          se && S.untap(se, le);
        }
        unsubAll(ne) {
          ne === void 0 ? (this.mults = {}) : delete this.mults[ne];
        }
      }
      (N.sub = (ne, le, se, ue) => ne.sub(le, se, ue)), (N.unsub = (
        ne,
        le,
        se
      ) => {
        ne.unsub(le, se);
      }), (N.unsubAll = (ne, le) => {
        ne.unsubAll(le);
      });
    },
    function(a, l, s) {
      'use strict';
      l.a = function(d) {
        const h = s.i(c.c)();
        return s.i(o.a)(() => h.close(), d), h;
      };
      var o = s(4), c = s(0);
    },
    function(a, l, s) {
      'use strict';
      Object.defineProperty(l, '__esModule', { value: !0 });
      var u = s(2), o = s(8), c = s(0);
      s.d(l, 'CLOSED', function() {
        return c.a;
      }), s.d(l, 'Channel', function() {
        return c.b;
      });
      var d = s(9);
      s.d(l, 'timeout', function() {
        return d.a;
      });
      var h = s(6);
      s.d(l, 'DEFAULT', function() {
        return h.a;
      });
      var b = s(3);
      s.d(l, 'put', function() {
        return b.a;
      }), s.d(l, 'take', function() {
        return b.b;
      }), s.d(l, 'offer', function() {
        return b.c;
      }), s.d(l, 'poll', function() {
        return b.d;
      }), s.d(l, 'sleep', function() {
        return b.e;
      }), s.d(l, 'alts', function() {
        return b.f;
      }), s.d(l, 'putAsync', function() {
        return b.g;
      }), s.d(l, 'takeAsync', function() {
        return b.h;
      });
      var g = s(5);
      s.d(l, 'spawn', function() {
        return g.a;
      }), s.d(l, 'go', function() {
        return g.b;
      }), s.d(l, 'chan', function() {
        return g.c;
      }), s.d(l, 'promiseChan', function() {
        return g.d;
      });
      const x = {
        mapFrom: o.a,
        mapInto: o.b,
        filterFrom: o.c,
        filterInto: o.d,
        removeFrom: o.e,
        removeInto: o.f,
        mapcatFrom: o.g,
        mapcatInto: o.h,
        pipe: o.i,
        split: o.j,
        reduce: o.k,
        onto: o.l,
        fromColl: o.m,
        map: o.n,
        merge: o.o,
        into: o.p,
        unique: o.q,
        partitionBy: o.r,
        partition: o.s,
        mult: o.t,
        mix: o.u,
        pub: o.v,
        pipeline: o.w,
        pipelineAsync: o.x,
        take: o.y,
      };
      l.operations = x;
      const k = { fixed: u.a, dropping: u.b, sliding: u.c, promise: u.d };
      l.buffers = k;
    },
    function(a, l, s) {
      'use strict';
      s(0);
      l.a = class {
        constructor(b) {
          this.channel = b;
        }
      };
      l.b = class {
        constructor(b, g) {
          (this.channel = b), (this.value = g);
        }
      };
      l.c = class {
        constructor(b) {
          this.msec = b;
        }
      };
      l.d = class {
        constructor(b, g) {
          (this.operations = b), (this.options = g);
        }
      };
    },
    function(a, l, s) {
      'use strict';
      l.a = function(_, M, E) {
        if (0 === _.length) throw new Error('Empty alt list');
        const O = new x.a(!0), U = g()(h()(_.length)), F = !!(E && E.priority);
        let I;
        for (let C = 0; C < _.length; C += 1) {
          const T = _[F ? C : U[C]];
          let L;
          if (
            (T instanceof k.b
              ? ((L = T), (I = L.take(new A.b(O, P => M(new y.b(P, L))))))
              : ((L = T[0]), (I = L.put(
                  T[1],
                  new A.b(O, P => M(new y.b(P, L)))
                ))), I)
          ) {
            M(new y.b(I.value, L));
            break;
          }
        }
        !I &&
          c()(E, 'default') &&
          O.value &&
          ((O.value = !1), M(new y.b(E.default, y.a)));
      };
      var o = s(22),
        c = s.n(o),
        d = s(24),
        h = s.n(d),
        b = s(14),
        g = s.n(b),
        x = s(1),
        k = s(0),
        A = s(7),
        y = s(6);
    },
    function(a, l, s) {
      'use strict';
      l.c = function(h, b) {
        for (; 0 < h.length; )
          b(h.pop());
      };
      var o = s(4);
      l.b = (h, b) => {
        s.i(o.b)(() => h(b));
      };
      l.a = h => h && h['@@transducer/reduced'];
    },
    function(a, l, s) {
      var o = s(18), c = s(21);
      a.exports = function(d) {
        return c(o(d));
      };
    },
    function(a) {
      a.exports = function(u, o) {
        return null == u ? void 0 : u[o];
      };
    },
    function(a) {
      var u = Math.floor, o = Math.random;
      a.exports = function(c, d) {
        return c + u(o() * (d - c + 1));
      };
    },
    function(a) {
      var u = Math.ceil, o = Math.max;
      a.exports = function(c, d, h, b) {
        for (var g = -1, x = o(u((d - c) / (h || 1)), 0), k = Array(x); x--; )
          (k[b ? x : ++g] = c), (c += h);
        return k;
      };
    },
    function(a) {
      a.exports = function(u, o) {
        var c = -1, d = u.length;
        for (o || (o = Array(d)); ++c < d; )
          o[c] = u[c];
        return o;
      };
    },
    function(a, l, s) {
      var o = s(17), c = s(20), d = s(26);
      a.exports = function(h) {
        return function(b, g, x) {
          return x &&
            'number' != typeof x &&
            c(b, g, x) &&
            (g = (x = void 0)), (b = d(b)), void 0 === g
            ? ((g = b), (b = 0))
            : (g = d(g)), (x = void 0 === x ? b < g ? 1 : -1 : d(x)), o(
            b,
            g,
            x,
            h
          );
        };
      };
    },
    function(a) {
      a.exports = function() {
        return !1;
      };
    },
    function(a, l, s) {
      var o = s(16);
      a.exports = function(c, d) {
        var h = -1, b = c.length;
        for (d = void 0 === d ? b : d; ++h < d; ) {
          var x = o(h, b - 1), k = c[x];
          (c[x] = c[h]), (c[h] = k);
        }
        return (c.length = d), c;
      };
    },
    function(a, l, s) {
      var o = s(15);
      a.exports = function(c, d, h) {
        var b = null == c ? void 0 : o(c, d);
        return b === void 0 ? h : b;
      };
    },
    function(a) {
      a.exports = function() {};
    },
    function(a, l, s) {
      var u = s(19), o = u();
      a.exports = o;
    },
    function(a) {
      a.exports = function(u, o) {
        for (var c = -1, d = Array(u); ++c < u; )
          d[c] = o(c);
        return d;
      };
    },
    function(a) {
      a.exports = function(u) {
        return u;
      };
    },
  ]);
});
